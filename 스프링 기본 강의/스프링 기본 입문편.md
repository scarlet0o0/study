# 스프링 기본 입문

- 스프링의 핵심원리
  - ioc di aop
  - 객체지향 설계
  - solid 원칙
- 스프링의 핵심 기능
  - 스프링 컨테이너 빈
  - 싱글톤
  - 컴포넌트 스캔
  - 의존관계 자동 주입
  - 빈 생명주기 콜백
  - 빈 스코드

<br/>

<br/>

## 스프링 컨테이너 빈

핵심용어 : **어플리케이션 콘텍스트**,  **스프링 빈**,  **스프링 컨테이너**,  **빈 팩토리**, **빈 디파이션**

- 스프링 컨테이너에서 빈 가져올때 방법
  1. 타입으로 가져오기
  2. 이름으로 가져오기

주의 : 빈의 이름은 유니크 하게 하라 중복될 수 있음

부모 타입으로 조회시 자식 타입도 같이 조회됨

<br/>

클래스 객체 이미지 하나 딱

<br/>

- aplicationcontext 는 beanfactory의 기능을 상속 다음
- apllicationcontext는  빈 관리 기능(beanfactory) 편리한 부가기능을 제공한다.
- apllicationcontext or beanfactory 둘다 스프링 컨테이너

<br/>

## 싱글톤 컨테이너

핵심용어 : **싱글톤 패턴, 싱글톤 컨테이너**

스프링 컨테이너는 성능 향상을 위해 싱글톤 패턴을 지원

싱글톤의 단점

1. 단일책임 원칙의 위배
2. 상속의 어려움 (개방 폐쇄 원칙 위반)
3. 테스트 하기 어려움

- 코드 자체에 구현에 힘이 들어감
- 의존 관계상 클라이언트가 구체 클래스에 의존
- ocp 원칙 위반

스프링 컨테이너는 바이트 단위로 클래스를 조작하여 싱글톤 컨테이너를 제공

<br/>

## 컴포넌트 스캔

핵심용어 : **컴포넌트, 컴포넌트 스캔, 오토와이드**

탐색위치

컴포넌트 스캔 기본 대상

중복 등록과 충돌

<br/>

<br/>

## 의존관계 자동 주입

### 의존관계 자동 주입 방법

- 생성자 주입
- 수정자 주입(setter 주입)
  - 선택, 변경이 있는 의존관계에 사용

- 필드 주입
  - 외부에서 변경이 불가능해 테스트 할시 어려움
  - DI 프레임워크가 없으면 아무것도 할수 없음

- 일반 메소드 주입

→ 생성자 주입 방법을 사용하자

- 불변이며 setter 와 달리 변경이 불가능
- final 을 사용해서 컴파일 단계에서 오류를 막을 수 있음

최신 트렌드

autowired

### 조회 빈이 두개 이상인 경우

- “@Qualifier, “@Primary

discountPolicy에 두 개의 빈이 찾아져버리므로, 특정 빈을 찾을 수 있도록 인자의 파라미터 이름을 수정해야했습니다. (@Autowired 필드명 방식)

이것이 개방-폐쇠 원칙을 못지킨 것이 아닌가 하는 의문이 들었습니다.

- 네 맞습니다. 클라이언트 코드를 고쳐야 하기 때문에 OCP를 지키기 못했습니다.

@Quilifier 혹은 @Primary 어노테이션을 붙이기 위해 구현체의 클래스를 찾아가서 수정해줘야하는 것 같습니다.

- 기존 구현 클래스의 애노테이션도 변경하지 않으면 더 좋겠지만, 이 부분까지는 컴포넌트 스캔의 한계입니다. @Bean을 사용하면 확실하게 되지만 약간은 불편하지요. 따라서 둘의 트레이드 오프로 이해하시면 됩니다.

## 수동 빈등록과 자동빈 등록

- 업무로직 빈
- 기술 지원 빈

<br/>

<br/>

## 빈 생명 주기 콜백

스프링 빈의 이벤트 라이플 사이클

**스프링 컨테이너 생성 → 스프링 빈 생성 → 의존 관계 주입 → 초기화 콜백 → 사용 → 소멸전 콜백 → 스프링 종료**

초기화 콜백 : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출

소멸전 콜백 : 빈이 소멸되기 직전에 호출

객체의 생성과 초기화를 분리하자.

생성자 : 필수 정보 (파라미터)를 받고 메모리를 할당해 객체를 생성하는 책임

초기화 : 외부 커넥션을 연결하는등 무거운 동작을 수행

3가지의 빈 생명주기 콜백

- 인터페이스(InitializingBean, DisposableBean) 상속 방법→ 오래된 방법
  - 단점 :
    - 스프링 전용 인터페이스의 의존
    - 초기화 소멸 메소드의 이름 변경 불가능
    - 외부 라이브러리에서는 적용 불가능
- 설정 정보에 초기화 메소드, 종료 메소드 지정
  - 메소드 이름을 자유롭게 제공 가능
  - 스프링 빈의 의존하지 않음
  - 외부 라이브러리에도 적용가능
- @postConstruct, @PreDestroy 애노테이션 지원
  - 최신 스프링 권장 방법
  - 애노테이션 하나로 편리
  - 스프링에 의존이 아닌 자바 표준 기술
  - 단점 : 외부 라이브러리 적용 불가능

## 빈 스코프

: 빈이 존재할 수 있는 범위

- 싱글톤 : 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위
- 프로토 타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여
- 웹 관련 스코프
  - request : 웹 요청이 들어오고 나갈때까지 유지되는 스코프
  - session : 웹 세션이 생성되고 종료될때까지 유지되는 스코프
  - application : 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

프로토 타입의 문제 해결 방법

- ObjectFactory : 기능이 단순 별도의 라이브러리 필요 없음
- ObjectProvider : ObjectFactory 상속, 옵션, 스트림 처리등 편의 기능이 많고, 별도의 라이브러리 필요 없음
- JSR-330 Provider ; 기능이 단순, 별도의 라이브러리 필요 자바 표준

특별할 일이 없으면 스프링이 제공해주는 ObjectProvider 사용

### 웹스코프

- 웹스코프는 웹 환경에서만 동작
- 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리

1. request : http 요청 하나가 들어오고 나갈때 까지 유지되는 스코프, 각각의 http 요청마다 별도의 빈 인스턴스가 생성되고 관리
2. session : http session과 동일한 생명주기를 가지는 스코프
3. aplication : 서블릿 컨텍스트 와 동일한 생명주기르 가지는 스코프
4. websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프