# 컬렉션

다수의 데이터를 저장하는 클래스

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있고 데이터 중복을 허용하는 데이터 집합 (ArrayList, LinkedList, Stack) |
| Set        | 순서가 없고 데이터 중복을 허용하지 않는 데이터 집합(HashSet, TreeSet) |
| Map        | 키와 값으로 이루어진 데이터집합 (HashMap, TreeMap)           |

<br/>

<br/>

## List

### ArrayList

배열을 사용해 데이터를 저장한다. 데이터를 읽어오고 저장하는 부분에는 효율이 좋지만 비순차적인 데이터를 삭제하거나 추가할때에는 효율이 떨어진다(배열의 용량이 변경될때).

### LinkedList

노드를 사용해 서로간의 주소를 저장함으로써 데이터를 저장한다. 데이터를 저장하거나 삭제할때 효율이 좋으면 데이터를 읽어오는 부분에서는 효율이 떨어진다.

#### ArrayList vs LinkedList

- 순차적으로 데이터를 추가하거나 삭제할때는데 ArrayList가 더 빠르다.
- 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList 보다 빠르다.

| 컬렉션     | 읽기    | 추가/삭제 | 비고                                                   |
| ---------- | ------- | --------- | ------------------------------------------------------ |
| ArrayList  | 빠르다  | 느리다    | 순처적인 추가 삭제는 더 빠르다. 비효율적인 메모리 사용 |
| LinkedList | 느리다. | 빠르다.   | 데이터가 많을수록 접근성이 떨어짐                      |

<br/>

<br/>

## Stack과 Queue

큐는 FIFO 스택은 LIFO

큐는 추가 삭제가 쉬운 LinkedList로 구현 

```java
Stack stack = new Stack();
Queue queue = new LinkedList();
```

### PriorityQueue(우선순위 큐)

저장한 순서에 상관없이 우선순위가 높은것부터 꺼내진다. 저장공간으로 배열을 사용하며 각 요소를 힙이라는 자료구조의 형태로 저장한다.

우선 순위큐는 추상 자료형으로써 우선순위 큐를 구현하기 위해 힙이라는 자료형이 사용된것이다.

<br/>

<br/>

## Arrays 

배열을 다루는 유용한 메소드들을 모아둔 클래스

1. copyOf(), copyOfRang() 배열의 복사
2. Fill(), setAll() 배열 채우기
3. sort(), binarySearch() 배열의 정렬과 검색(이진검색)
4. equals(), toString(), deepEquals(), deepToString() 문자열의 비교와 출력
5. asList() 배열을 불변리스트로 변환 (동적배열을 사용하기우해서는 ArrayList생성자로 감싸주자)

<br/>

<br/>

## Comparator와 comparable 

- compareble : 기본 정렬기준을 구현하는데 사용 (내부)
- Comparetor : 기본 정렬기준 외에 다른 기준으로 정렬하고자 사용 (외부)

<br/>

<br/>

## Set

- HashSet : 순서 상관없이 저장하며 중복된 요소는 저장하지 않는다.
- LinkedHashSet : 순서 있게 저장하며 중복된 요소는 저장하지 않는다.

### equals 와 HashCode

두 객체에 대해서 equals가 같은 경우 HashCode 또한 무조건 같아야 한다. 그렇지 않으면 Hash를 사용하는 자료형에서 문제가 생긴다. equals가 다른경우 HashCode는 같아도 되지만 HashCode가 다른게 성능상으로 더 좋다.

### Tree Set

이진 검색 트리 라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스 (정렬, 검색, 범위 검색)

Tree Set은 이진 검색 트리의 성능을 향샹시킨 레드블랙트리로 구성되어 있다.

- 모든 노드는 최대 두개의 자식 노드를 가진다.
- 왼쪽 자식노드는 부모모다 작고 오른쪽 자식 노드는 부모보다 크다.
- 노드의 추가 삭제에 시간이 걸린다.
- 검색과 정렬의 유용하다.
- 중복된 값을 저장하지 못한다.

<br/>

<br/>

## HashMap

```java
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable {
		// 내부 배열 (해시 버킷)
    transient Node<K,V>[] table;

    // 현재 `HashMap`에 저장된 엔트리의 수
    transient int size;

    // 엔트리 클래스 (연결 리스트의 노드)
    static class Node<K,V> implements Map.Entry<K,V> { //객체지향적으로 묶은 모습
        final K key;
        V value;
    }
}
```

**static inner interface**는 클래스 내부에 정의된 인터페이스로, 그 클래스와 관련된 기능이나 역할을 정의하는 데 사용됩니다. 클래스의 객체를 만들지 않고도 사용할 수 있기 때문에, 관련된 기능들을 논리적으로 그룹화할 때 유용합니다.

쉽게 말해, 특정 클래스와 관련된 기능을 정의하고, 그 기능을 다른 곳에서도 사용하고 싶을 때 사용합니다. 예를 들어, 버튼을 클릭했을 때 어떤 동작을 할지 정의하거나, 문서의 텍스트를 형식화하거나, 게임에서 플레이어 역할을 정의하는 경우 등이 있습니다.



### 해싱과 해시함수

- 해싱 : 데이터를 일정한 크기의 값으로 변환하는 과정
- 해시 함수 : 해싱을 행하는 함수

#### 해시함수의 특성

1. **빠른 계산**: 해시 함수는 빠르게 계산되어야 합니다.
2. **균등 분포**: 입력 키가 해시 테이블의 모든 인덱스에 균등하게 분포되도록 해야 합니다.
3. **결정적**: 동일한 입력에 대해 항상 동일한 해시 값을 반환해야 합니다.
4. **충돌 최소화**: 서로 다른 입력에 대해 동일한 해시 값을 반환하는 경우(충돌)가 최소화되어야 합니다.

##### 충돌

1. **체이닝(Chaining)**: 각 버킷을 링크드 리스트로 구현하여 충돌이 발생하면 동일한 버킷에 연결합니다.
2. **오픈 어드레싱(Open Addressing)**: 충돌이 발생하면 다른 빈 버킷을 찾아 저장합니다. 일반적인 기법으로는 선형 탐사, 제곱 탐사, 이중 해싱이 있습니다.

##### 최근 HashMap

- **충돌 처리**: 체이닝(링크드 리스트)과 트리화(레드-블랙 트리)를 사용하여 충돌을 처리합니다.
- **재해시**: 해시 테이블이 가득 차면 크기를 두 배로 늘리고 재해시합니다.

<br/>

### TreeMap

이진 검색트리의 형태로 키와 값의 쌍으로 이루어지는 데이터를 저장

<br/>

<br/>

## Collections

컬렉션과 관련된 메소드들을 지원한다. 

- fIll()
- Copy()
- sort()
- binarySearch()

- 컬렉션의 동기화
- 컬렉션의 변경불가
- 컬렉션의 싱글톤