# 컬렉션

다수의 데이터를 저장하는 클래스

| 인터페이스 | 특징                                                         |
| ---------- | ------------------------------------------------------------ |
| List       | 순서가 있고 데이터 중복을 허용하는 데이터 집합 (ArrayList, LinkedList, Stack) |
| Set        | 순서가 없고 데이터 중복을 허용하지 않는 데이터 집합(HashSet, TreeSet) |
| Map        | 키와 값으로 이루어진 데이터집합 (HashMap, TreeMap)           |

<br/>

<br/>

## List

### ArrayList

배열을 사용해 데이터를 저장한다. 데이터를 읽어오고 저장하는 부분에는 효율이 좋지만 비순차적인 데이터를 삭제하거나 추가할때에는 효율이 떨어진다(배열의 용량이 변경될때).

### LinkedList

노드를 사용해 서로간의 주소를 저장함으로써 데이터를 저장한다. 데이터를 저장하거나 삭제할때 효율이 좋으면 데이터를 읽어오는 부분에서는 효율이 떨어진다.

#### ArrayList vs LinkedList

- 순차적으로 데이터를 추가하거나 삭제할때는데 ArrayList가 더 빠르다.
- 중간 데이터를 추가/삭제하는 경우에는 LinkedList가 ArrayList 보다 빠르다.

| 컬렉션     | 읽기    | 추가/삭제 | 비고                                                   |
| ---------- | ------- | --------- | ------------------------------------------------------ |
| ArrayList  | 빠르다  | 느리다    | 순처적인 추가 삭제는 더 빠르다. 비효율적인 메모리 사용 |
| LinkedList | 느리다. | 빠르다.   | 데이터가 많을수록 접근성이 떨어짐                      |

<br/>

<br/>

## Stack과 Queue

큐는 FIFO 스택은 LIFO

큐는 추가 삭제가 쉬운 LinkedList로 구현 

```java
Stack stack = new Stack();
Queue queue = new LinkedList();
```

### PriorityQueue(우선순위 큐)

저장한 순서에 상관없이 우선순위가 높은것부터 꺼내진다. 저장공간으로 배열을 사용하며 각 요소를 힙이라는 자료구조의 형태로 저장한다.

우선 순위큐는 추상 자료형으로써 우선순위 큐를 구현하기 위해 힙이라는 자료형이 사용된것이다.

<br/>

<br/>

## Arrays 

배열을 다루는 유용한 메소드들을 모아둔 클래스

1. copyOf(), copyOfRang() 배열의 복사
2. Fill(), setAll() 배열 채우기
3. sort(), binarySearch() 배열의 정렬과 검색(이진검색)
4. equals(), toString(), deepEquals(), deepToString() 문자열의 비교와 출력
5. asList() 배열을 불변리스트로 변환 (동적배열을 사용하기우해서는 ArrayList생성자로 감싸주자)

<br/>

<br/>

## Comparator와 comparable 

- compareble : 기본 정렬기준을 구현하는데 사용 (내부)
- Comparetor : 기본 정렬기준 외에 다른 기준으로 정렬하고자 사용 (외부)